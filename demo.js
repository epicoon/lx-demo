




Составить нормальный список с описанием директив компилятора
#lx:require
#lx:widget
#lx:script
#lx:yaml
#lx:mode-case
#lx:mode-end

#lx:model
#lx:model-collection
#lx:MODEL_NAME

#lx:namespace
#lx:private
#lx:use

#lx:schema
#lx:behavior(s)

->
->>
~>
^

?>#id
?>#{id}
?>.class
?>.{class}
?>name
?>{name}


















Роутинг
Есть роутер уровня приложения
    Должен быть максимально гибким
    Основная задача - обработка реального роута, отпределение на основании него отвечающего сервиса
    
    Варианты работы карты:
        
        # Жесткое сопоставление роута и отвечающего сервиса
	        hard/route: serviceName
	        hard/route: {service: serviceName}
        # Жесткое сопоставление роута внутреннему роуту отвечающего сервиса (его переопределение)
    	    hard/route: serviceName/route/in/service
    	    hard/route: {service-route: serviceName/route/in/service}
        # Использование домена для роутинга сервиса:
        # доменная часть используется только для определения сервиса
        # после чего она отбрасывается и оставшаяся часть урла определяется как ключи роутинга сервиса
        	!domen-route: serviceName
        # Сопоставление по регулярному выражению
        	~route: serviceName
        
        # Замыкание напрямую на контроллер
        	route: {service-controller: serviceName:ControllerName}
        	route: {service-controller: serviceName:ControllerName::actionName}
        # Замыкание напрямую на экшен
        	route: {service-action: serviceName:ActionName}
        # Замыкание напрямую на модуль
        	route: {service-module: serviceName:moduleName}

        # Вариант с условием по моду
        	route: {service: serviceName, on-mode: [mode]}


Роутер сервиса
    Карта выглядит так:
        route/name: %отвечающая сущность%
        ... 
    Варианты отвечающих сущностей:    
    - контроллер
	    ControllerClassName
        ControllerClassName::actionName
        {controller: ControllerClassName::actionName, on-service-mode: [mode]}
    - экшен
        {action: ActionClassName}
    - модуль
        {module: modueName}






































https://www.youtube.com/watch?v=_X0LvpC7af0

https://hackertyper.net/
http://devanswers.ru/a/Uh

1. Введение
	1.1. Предисловие
	1.2. Разворачивание
	1.3. Настройки сервера +
	1.4. ООП-Gui
		1.4.1. Общая картина
		1.4.2. Создание элементов ++
		1.4.3. Добавление элементов ++
2. Приложение
	2.1. Структура приложения ++
	2.2. AJAX-взаимодействие ++
	2.3. Конфиг приложения (варианты роутинга по модулям приложения) ++
	2.4. Модульная архитектура >>
	2.5. Общий конфиг модулей >>
	2.6. Js-компилятор (входная точка в клиентскую сторону модуля в конфиге задается, далее ветвление может быть любым) >>
	2.7. Пример простейшего приложения ++
3. Модуль
	3.1. Общая информация
	3.2. Конфиг
	3.3. Классификация
	3.4. Вложение модулей
	3.5. Возможности на сервере (методы, подробнее про формирование ответов и роутинг по вложенным модулям)
	3.6. Возможности на клиенте (методы, запросы, хэндлеры модуля)
4. Концепции js //(переименовать - сторона клиента. Поменять местами со следующим блоком)
	4.1. Директивы js-компилятора
	4.2. Расширенный синтаксис
	4.3. Расширение сущностей языка  (app/js_extends)
	// Компоненты (связывания отдельным пунктом оставить как важный функционал. Поведения хз)
	// Хелперы
	// --- сюда переместить инструменты
	// --- сюда структуры данных (или в инструменты их засунуть и одним блоком)
	4.4. Стратегии позиционирования +
	4.5. Поведения
	4.6. Связывания +
	4.7. Структуры данных
		4.7.1. Collection
		4.7.2. Tree
	4.8. Инструменты
		4.8.1. Timer
		4.8.2. Synchronizer ++
		4.8.3. Singleton
		4.8.4. KeypressManager
5. Концепции php //(переименовать - сторона сервера)
	// Автоподключение классов
	// Компоненты - сюда про кондукторая, про диалог
	5.1. Conductor >>
	5.2. Dialog >>
	5.3. Object //его вообще переименовывать
	5.4. Respondent
	5.5. Структуры данных
		5.5.1. Collection
		5.5.2. Tree
		5.5.3. Vector
	5.6. Инструменты
		5.6.1. Db
		5.6.2. File
		5.6.3. Yaml ++
		5.6.4. Math
6. GUI
	6.1. Общая схема виджетов
	6.2. Виджеты по каждому (на js, на php)
	6.3. Блоки
7. HTMP
	7.1. Обзор
8. Инструментальные модули
	8.1. codeRedactor
	8.2. db/manager
	8.3. db/tableToTable



<p>[[:
	<ru>
	</ru>
	<en>
	</en>
:]]</p>








Здравствуй, дорогой мой читатель. Сегодня я готов поделиться с тобой своей страстью. Страстью к разработке инструментов разработки.
Да, именно то, что принято называть "изобретением велосипедов". Но как я могу остановиться, когда это приносит столько удовольствия.

К делу. То, что начиналось как безобидная крохотная библиотека для личного пользования, со временем стало неприлично большим и постепенно перерасло
сначала во фреймворк, а теперь уже и в платформу.

Внимательный читатель заметит - а почему я так вольготно манипулирую этими терминами - где она эта грань?
Что является библиотекой, что фрэймворком, что платформой? И читатель прав, прежде чем двинуться в безумный и прекрасный мир абстракций, архитектурных систем
и просто неожиданных хулиганских решений, нужно определиться с терминами. Даже с, казалось бы, малозначительными.

Что же такое библиотека? Очевидно и просто - это набор функций и/или классов, решающих какие-то прикладные задачи и ни к чему особенно не обязывающий.
В то, как вам выстраивать архитектуру приложения, библиотеки не лезут. Хорошо. Тогда мне скажут - есть же такое понятие как микрофрэймворк - он тоже содержит
набор классов для решения прикладных задач и не претендует на перекраивание архитектуры вашего приложения. Бинго! Так и есть, микрофрэймворк по предложенному
мной определению ничем от библиотеки не отличается и фактически ею является. И согласно моему мнению, такое "красивое" название как "микрофрэймворк" мы имеем
из-за популярности слова "фрэймворк", желания придать той или иной библиотеке больше авторитета (хотя если библиотека полезная, и ее полезность говорит сама за себя,
не совсем понятно зачем нагонять лишний пафос) и проявления маркетологического мышления у ряда людей. Призываю не плодить лишних сущностей и забыть про этот термин.
Если он вам дорог, то забыть хотя бы на страницах данной документации.

Определились, идем дальше - фрэймворк. Уже из предыдущего определения напрашивается, что он влияет на архитерктуру приложения. Так и есть. Он так же предоставляет
набор функций и/или классов, но при этом предлагает готовое решение по архитерктуре, которому вам придется следовать в своем приложении. В большинстве случаев это,
конечно, удобно. Уходить в анализ отдельных фрэймворков не будем - там много вкусовщины и демагогии. Сосредоточимся на едином для всех них факте - большинство задач
удобнее решать с использованием того или иного фрэймворка. При повышении сложности задачи, ее нестандартности, полезность фрэймворков может сильно снижаться и даже
превращаться во вред. Важно понимать - фрэймворк - не панацея, не универсальное решение всех ваших проблем, это инструмент. И чем лучше вы знаете инструмент, тем
лучше понимаете область его применимости и границы полезности.

Добрались до платформы. Тут всё просто, это система упраления архитектурой. Она манипулируюет более общими сущностями, чем классы, выходит за рамки определенного
языка, связывает код, исполняемый на разных устройствах в единую структуру. Мне возразят - но ведь фрэймворки тоже так умеют! В чем принципиальная разница?
//???
// Надо как-то понятнее обосновать
- компилятор файлов
- расширенный синтаксис
- оперирование сущностями, существующими и на сервере и на клиенте (модули, виджеты)
//???
!!!!!!!!!!!!!!!!!!!!!!!!!!
Выяснилось, что платформа и фрэймворк синонимы, но!
отличия платформы придумал:
1. Это самодостаточный продукт с минимумом зависимостей
2. Это условно готовый продукт, который не требудет допиливания со стороны разработчика клиентского кода



Теперь, когда мы в общих чертах представляем с чем будем иметь дело, самое время выделить некоторые идеи, подтолкнувшие меня к созданию такой платформы. Надеюсь это
прояснит ее направленность и особенности.
//???
// Нормально все написать
1. Разделение на фронтэнд и бэкэнд - разделение труда, оптимизация производственного процесса, конвеер все дела, но так было только в самом начале.
На практике у фронтов - есть свой сервер, у бэка - своя верстка, н-р админка. Разделение на фронт и бэк изменило свой смысл - теперь это разработчики части системы,
более близкой к потребителю системы и части системы, более близкой к администратору системы. При этом с клиентской стороной и с серверной приходится работать и тем
и тем, при этом взаимодействие этих сторон плохое.
2. Интерфейсы с помощью HTML - говнище ебаное
3. Существующие решения 2 проблемы тоже привязываются к HTML, где нормальное ОО-решение?
4. Когда за дело берется бэкэнд, получаем постоянные перезагрузки страницы на каждый пук, по несколько полос прокрутки одновременно (чем страдают вообще все),
страница со сложным интерфейсом выглядит как одна газета, брошенная поверх другой. Работать можно, но зачем это терпеть?
5. Когда за дело берутся фронты получаем тонкий клиент - все расчеты, даже те, которые реально и безопасно делать на клиенте выкидывают на сервер. Считается, что
на JS писать ООП-систему труднее, чем на статических языках. Но это только кажется.
6. Плохое структурирование компонентов системы - каталоги возникают произвольно, файлы с кодом множатся, как-то ориентироваться становится трудно
7. Миллионы микропакетов. Как вы в них ориентируетесь вообще?
//???




















































































!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Про блоки
- можно фигачить блок как файлик, можно как директорию
- у блока может быть свой js-код (и бутстрап и обычный)
	- бутстрап отрабатывает сразу после загрузки блока
	- обычный - после загрузки всего модуля
	- в обоих случаях доступны контекстные переменные
		- Block - ссылка на элемент блока
		- clientParams - объект с полями, которые можно задать на php, когда блок загружается в элемент











2.4.
ВСЕ ПОМЕНЯЛОСЬ!!!

Основная единица приложения - модуль. Модуль - самодостаточная, функционально независимая часть приложения.
Модуль имеет свои серверную и клиентскую части.
Модуль может иметь вложенные модули.
Модуль может использовать другие модули.
Модуль может использоваться с параметрами.

Какие есть модули:
- Внутриструктурные - участвуют в выстраивании архитектуры приложения
	- Корневые - расположенные непосредственно в приложении
		- локализованные (которые лежат в стандартной папке модулей)
		- роутируемые (для которых заданы пути в конфиге приложения)
	- Вложенные - расположенные в других модулях
		- локализованные (которые лежат в стандартной папке модулей)
		- роутируемые (для которых заданы пути в конфиге родительского модуля)
- Внеструктурные - инструментальные модули, непосредственно не включенные в архитектуру приложения, но могут использоваться другими модулями.

Способы поместить один модуль в другой:
1. Непосредственно размещение внутри родительских
	- по стандартному пути (специальный каталог для модулей)
		- тогда собственным именем модуля считается имя его каталога
		- полное имя модуля - имя родителя / собственное имя
	- по индивидуальному ключу в конфигах где перечисляются модули
		- тогда собственным именем модуля считается этот ключ 
		- полное имя модуля - имя родителя / собственное имя
2. Подключение инструментальных модулей в конфигах, где перечисляются модули, указав путь (и параметры при необходимости)
3. На стороне сервера можно вызвать метод элемента Box::setModule($config) для размещения модуля в элементе
	- можно передать непосредственно модуль
	- можно передать массив конфигов (путь и параметры)
	- можно передать только путь (или полное имя) - строкой
4. На стороне клиента можно загрузить модуль в элемент с помощью AJAX методом Box.loadModule(moduleName, onResponseHandler)

!Ввести понятие самоидентификации модуля

В результате включения модуля могут быть варианты самоидентификации модуля:
1. Корневой модуль - для самоидентификации достаточно собственного имени
2. Определенный через конфиг модуль - в полном имени хранит роут - как до него добраться
3. Внешний модуль (в т.ч. инструментальный), подколюченный через конфиг - хранит свое полное имя - роут согласно конфигу
4. Внешний модуль, подключенный непосредственно через элемент
	- если подключен непосредственно модуль - он имеет корректное имя (роут)
	- если модуль собирался из переданных данных
		- если этот модуль корневой, то проблем нет - он себя найдет - его собственное имя совпадает с route
		- если этот модуль вложенный в родительский модуль элемента, то аналогично п2.
		- если это модуль вложенный в какой-то другой модуль (подключен прямым указанием пути), то у него могут быть проблемы в самоидентификацией:
			- он создастся как корневой - его имя будет равно собственному имени
			- если он не предусматривает логику ajax-запросов, то проблем нет
			- если ajax-запросы в его логике присутствуют, то работать они не будут, т.к. для его варианта сборки просто не существует route

!!!!!!!!!!!!!!! Более актуальное !!!!!!!!!!!!!!!!!!!!!!!!!!!
Глобально - приложение может работать в вариантах:
	- браузерное, т.е. клиент-серверное: серверная часть получает запрос от клиентской, формирует ответ и отдает
	- консольное - консольная команда может рассматриваться как запрос к приложению. Приложение отвечает действием

Приложение состоит из пакетов

У приложения есть карта пакетов
	Имя пакета сопоставляется с путем к его каталогу относительно корня приложения
	Имя пакета, согласно PSR, это имя_вендора + '/' + имя_самого_пакета

Каждый пакет имеет конфигурацию (lx-config|lx-config/main).(php|yaml)
	В конфигурации определено
		name
		autoload

Виды пакетов
	Библиотека - просто набор классов и/или функций
	Сервис - логическая структура, способная принимать запросы и возвращать ответы

С пакетами-библиотеками все просто - это просто провайдеры классов

Пакеты-сервисы используются приложением для обработки запросов и формирования ответов:

	У приложения есть роутер, маршрутизирующий запросы по сервисам
		1. Это может быть массив с ключами-урлами (в т.ч. используя регулярки),
		значениями - именами сервисов (м.б. массивом сервисов? Один URL будет обслуживаться несколькими сервисами - кто первый сможет ответить)
		2. Это может быть скрипт - php-код, управляющий урлами
		3. Это может быть класс, управляющий урлами
		* В конфиге это будет выглядеть примерно так:
			router:
			  type: class
			  name: name\of\Class
		* Напрашивается дефолтный класс-роутер, от которого будет наследоваться клиентский роутер. И который будет использоваться, если роутер не определен
			Нужно придумать дефолтную логику роутинга
		* При переопределении роута приходим к факту "глобального" php-кода - на уровне приложения, не в пакете. Насколько это преемлемо?

	Сервис принимает запрос от приложения и отвечает приложению

	Сервис внутри себя перенаправляет запрос на контроллеры

	Контроллер определяет какого типа пришел запрос
		API
		консоли

	Сервис может иметь модули
		Модуль это связка котроллера и вьюхи
		Т.о. модуль имеет GUI
		Модуль рендерится
		Клиентская сторона модуля поддерживает связь с серверной через AJAX

	Модуль определяет какого типа пришел запрос (! определяет таки приложение)
		на рендеринг
		AJAX














2.5.
/*
В каждом модуле может быть создан файл config.php или config/main.php с индивидуальными настройками.
Если файла нет, или в нем отсутствуют какие-либо настройки, они будут браться из файла config/module.php
*/
return [
	//todo - там с определением имени все сложнее стало, оно часть роута и самоидентификации модуля, проверить есть ли смысл тут в этом
	// 'name' => '',  // имеет смысл только в конфигах конкретного модуля. Если не указан - берется имя каталога модуля

	// имеет смысл только в конфигах конкретного модуля
	// 'aliases' => [],

	// Набор алиасов, используемый всеми модулями
	'commonAliases' => [],
	// В конкретном модуле можно установить значение false, тогда общие алиасы не будут импортироваться
	'useCommonAliases' => true,

	// Соглашения внутренней структуры модуля - не включены в алиасы, т.к. имеют особое значение для целостности модуля, ключи неизменны
	// каталог с js-кодом, основным кодом приложения, исполняемым на клиенте
	'frontend' => 'frontend',
	// js-код, выполняемый до загрузки блоков модуля
	'jsBootstrap' => '_bootstrap.js',
	// основной js-код
	'jsMain' => '_main.js',
	// ответчики - php-скрипты, обрабатывающие ajax-запросы
	'respondents' => 'backend',
	// каталог с блоками интерфейса
	'view' => 'view',
	// корневой блок
	'viewIndex' => '_root.php',
	// расположение вложенных модулей
	'modulesDirectory' => 'modules',
	// расположение ресурсов
	'images' => 'assets/images',
	'css' => 'assets/css',

	//todo - надо возможность связи с несколькими базами
	// настройки подключения к базе данных могут быть индивидуальными для каждого модуля
	'db' => [
		'hostname' => 'localhost',
		'username' => 'postgres',
		'password' => '123456',
		'dbName' => 'alden'
	],
];

2.6.
Для полноты картины сейчас нужна базовая информация об организации js-кода.
В рамках модуля для клиентской стороны существует основной исполняемый js-файл.
Путь к нему задается в конфиге модуля.
Благодаря js-компилятору в один js-файл можно включать другие при помощи директивы '#lx:require'.

Например, в конфиге модуля есть настройки:
'frontend' => 'frontend',
'jsMain' => '_main.js',
Тогда основной исполняемый js-файл находится по адресу frontend/_main.js относительно корневой директории модуля.
Благодаря однозначному определению входной точки в клиентский код модуля, никаких дополнительных усилий для
подключения js-кода не требуется.

Примеры. Допустим в этом файле имеются директивы включения других js-файлов:
// Будет искаться файл example1.js в той же директории, что и текущий js-файл
#lx:require example1;
// Будет искаться файл example2.js в директории directory относительно текущего js-файла
#lx:require directory/example2;
// Поиск будет производиться согласно заданным алиасам в модуле (или приложении, если модуль не имеет такого алиаса)
// При этом т.к. путь заканчивается на '/' - example3 это директория и присоединены будут все js-файлы, которые в ней (непосредственно) лежат
#lx:require @someAlias/example3/;
// Чтобы присоединить рекурсивно вообще все js-файлы в директории, можно испотльзовать флаг '-R'
#lx:require -R example4/;

Есть и другие способы использования внешних файлов. Есть директивы js-компилятора, выполняющие другие функции.
Подробный разбор директив js-компилятора изложен в соответствующей статье !!!ссылка!!!.













5.1
Conductor это системный компонент, предоставляющая информацию о ключевых путях приложения.
Доступен как \lx::$conductor;
Описать что за пути он дает и как

5.2
Dialog это системный компонент, предоставляющая информацию о запросе, полученном от клиента.
Доступен как \lx::$dialog;
Описать методы















+++
* про связывания еще надо хороший пример для экстраполя на метод
  + подробный пример кастомизации метода value() - как в fc.iiAxisPult()
* всякие Rect::locateBy() и т.п.
* выход за пределы родительского элемента









!!!!!!!!!!!!!!!!!!
Про виджеты
- есть встроенные в платформу, они находятся в пространстве имен lx
- можно создавать пользовательские - пространства имен для них определяются в конфиге приложения
- виджеты это сущности уровня приложения. Если есть необходимость оформить блок графического интерфейса узкоспециализированно для конкретного модуля -
	виджет использовать не нужно. Эту задачу нужно решать с помощью обычных классов (можно - классы на стороне сервера + добавление динамики на клиенте,
	либо полностью решение на клиенте - в зависимости от задачи).
	Философия виджета же - это межмодульное универсальное решение для графического интерфейса.



















/*** Немного о моделях ***/
class Test extends lx.Model {
	field
		aaa : {default: 11},
		bbb,
		ccc << arr[0],
		ddd << arr[1] : {default: 'ee'};

	constructor() {
		super();

		this.arr = [0, 1];
	}
}

var t = new Test();
t.ccc = 12;
console.log(t);



// И еще такое:
// ответчик
<?php

namespace backend;

class Respondent extends \lx\Respondent {

	public function sum($a, $b) {
		return $a + $b;
	}

	public function getRand() {
		return \lx\Math::rand(1, 10);
	}

}

// В jsBootstrap
lx.Box.defaultMatrixItemBox = [lx.Form, {grid:{indent:'10px', paddingBottom:'0px'}}];

// модель
Aaa:
  fields:
    x: 1
    y: false
// js-код
#lx:model e = { a, b, sum };
var f = new lx.Form({ geom: [10, 10, 20, 40] });
f.border();
f.grid({indent: '10px'});
f.fields({
	a  : [ lx.Input, {width:4} ],
	b  : [ lx.Input, {width:4} ],
	sum: [ lx.Box,   {width:4} ]
});
f.button('rand a', {width:4}, ()=>e.a=^Respondent.getRand());
f.button('rand b', {width:4}, ()=>e.b=^Respondent.getRand());
f.button('sum', {width:4}, function(){
	var a = this~>a.value(),
		b = this~>b.value();
	if (!a.isNumber || !b.isNumber) { lx.Tost.error('WTF?'); return; }
	e.sum = ^Respondent.sum(a, b);
});
e.bind(f);

lx.Box.defaultMatrixItemBox = [lx.Form, {grid:{indent:'10px', paddingBottom:'0px'}}];
#lx:model-collection c = #lx:MODEL_NAME Aaa;
var ff = new lx.Box({ geom: [50, 10, 40, 40] });
ff.border();
ff.stream();
ff.matrix(c, (form)=>{
	form.fields({
		x: [ lx.Box, {width:3} ],
		y: [ lx.Box, {width:3} ]
	});
	form.getChildren().call('border').call('align', lx.CENTER, lx.MIDDLE);
});
c.add({ x: 3, y: 5 });
c.add({ x: 13, y: 15 });
c.add();































/*** Как добавляется всякое в пространство имен ***/
//!!!!!!!!!!!!!!!!!!! УСТАРЕЛО
#lx:require {
	Test,
	Test2
} in opa;
/*
это создает поле window.opa и текущий модуль запоминает, что он это поле добавил. При удалении модуля поле будет удалено
в поле, как в пространстве имен находятся подключенные классы
*/

var t = new opa.Test();
var t2 = new opa.Test2();

console.log(t);
// При этом объекты знают о своем пространстве имен
console.log(t.namespace);
// Можно получить имя класса без пространства имен
console.log(t.className);
// Можно получить имя класса с пространством имен
console.log(t.fullClassName);

// Сам класс тоже знает о своем пространстве имен
console.log(opa.Test.namespace);
// Имя класса узнается стандартно
console.log(opa.Test.name);
// Соответствующий метод для полного имени класса
console.log(opa.Test.fullName);































// пыховый демо-код

//=============================================================================================================================
// Создание хэндлера. Можно и в js его делать - и для модуля и глобальные - в файлах _bootstrap.js
$Module->setHandler('hm_test2', '()=> 
	console.log("hm_test2");
	console.log(this);
	console.log(Module);
	console.log("-----END-----");

	^Resp.getYaml() : (res)=> { console.log(res); };
');

$b2 = new lx\Button([
	'geom' => [10, 30, 10, 4],
	'click' => '->hm_test2'
]);
//=============================================================================================================================



// ActiveBox
// RequestButton
// Form


//=============================================================================================================================
// ActiveBox
// RequestButton
// Form
$el = new lx\ActiveBox([
	'key' => 'ab',
	'geom' => [10, 10, 40, 40],
	'header' => 'rgrgrgr',
	'body' => lx\Form::className()
]);
$el->border();
$el->get('header')->fill('gray')->style('color', 'white');

$form = $el->get('body');
$form->grid([
	'sizeBehavior' => lx\GridPositioningStrategy::SIZE_BEHAVIOR_PROPORTIONAL
]);

$form->fill('white');

$config = ['labelSize' => '100px'];
$form->labeledFields([
	'login' => ['Login',    lx\Input::class, $config],
	'pass'  => ['Password', lx\Input::class, $config],
	'rem'   => [lx\Checkbox::class, 'Remember',    ['width' => 4]],
	'my'    => [lx\Checkbox::class, 'My computer', ['width' => 4]],
	'opa'   => [lx\Checkbox::class, 'Some else',   ['width' => 4]],
]);

$form->fields([
	'radio' => [lx\RadioGroup::class, [
		'labels' => [
			'Guest',
			'User',
			'Admin'
		],
		'left' => 1,
		'size' => [5, 3]
	]],
	'radio2' => [lx\RadioGroup::class, [
		'labels' => [
			'Fuck everithing',
			'Kill them all',
			'Do nothing'
		],
		'size' => [5, 3]
	]]
]);

new lx\RequestButton([
	'parent' => $form,
	'left' => 3,
	'width' => 6,
	'text' => 'Submit',
	'style' => ['fill' => 'Gray', 'color' => 'white']
]);
// ActiveBox
// RequestButton
// Form
//=============================================================================================================================


//=============================================================================================================================
// Формы для связей
$f = new lx\Form([
	'key' => 'f',
	'grid' => ['cols' => 2]
	'geom' => [10, 5, 40, 40]
]);
$f->border();
$f->fields([
	'name' => [ lx\Input::class, ['width' => 1] ],
	'num' => [ lx\Input::class, ['width' => 1] ],
	'val' => [ lx\RadioGroup::class, ['size' => [1, 3], 'labels' => ['one', 'two', 'three']] ],
	'arr' => [ lx\CheckboxGroup::class, ['size' => [1, 3], 'labels' => ['one', 'two', 'three']] ]
]);

$f2 = new lx\Form([
	'key' => 'f2',
	'geom' => [55, 5, 40, 40]
]);
$f2->border();
$f2->fields([
	'name' => [ lx\Input::class, ['width' => 1] ],
	'num' => [ lx\Input::class, ['width' => 1] ],
	'val' => [ lx\RadioGroup::class, ['size' => [1, 3], 'labels' => ['one', 'two', 'three']] ],
	'arr' => [ lx\CheckboxGroup::class, ['size' => [1, 3], 'labels' => ['one', 'two', 'three']] ]
]);

// Для js
// код класса для t (Test) см в demo.js
t.bind(Module->f, Module->f2);
// Формы для связей
//=============================================================================================================================


//=============================================================================================================================
// Пример проводника
$tree = new lx\Tree('a', 'b', 'c', 'a/a');
$el = new lx\TreeBox([
	'geom' => [10, 10, 40, 40],
	'data' => $tree,
	'leaf' => '()=> this->label.text(this.node.fullKey());'
]);
$el->border();
//=============================================================================================================================


//=============================================================================================================================
// Пример выравниваний
$el = new lx\Box([
	'geom' => [10, 10, 40, 40]
]);
$el->border();

$el0 = new lx\Box([
	'parent' => $el,
	'key' => 'opa',
	'size' => [30, 30]
]);
$el0->fill('green');

$el1 = new lx\Box([
	'parent' => $el,
	'key' => 'eee',
	'size' => [20, 20]
]);
$el1->fill('blue');

$el2 = new lx\Box([
	'parent' => $el,
	'key' => 'eee',
	'size' => [10, 10]
]);
$el2->fill('red');

$el->align(CENTER, MIDDLE);
$el->align(RIGHT, BOTTOM, 'eee');
//=============================================================================================================================


//=============================================================================================================================
// Пример потока
$b = new lx\Box([
	'geom' => [10, 40, 40, 40]
]);
$b->border();
$b->stream([
	'sizeBehavior' => lx\StreamPositioningStrategy::SIZE_BEHAVIOR_BY_CONTENT,
	'indent' => '5px'
]);
$b->begin();

$el1 = new lx\Box([
	'height' => '20px'
]);

$el2 = new lx\Box([
	'height' => '30px'
]);

$b->getChildren()->call('border');
//=============================================================================================================================


//=============================================================================================================================
// Пример потока пропорционального
$b = new lx\Box([
	'geom' => [10, 10, 40, 40]
]);
$b->border();
$b->stream([
	'sizeBehavior' => lx\StreamPositioningStrategy::SIZE_BEHAVIOR_PROPORTIONAL,
	'indent' => '5px'
]);
$b->begin();
lx\Box::construct(10);
$b->getChildren()->call('border');
$b->child(2)->fill('green');
//=============================================================================================================================


