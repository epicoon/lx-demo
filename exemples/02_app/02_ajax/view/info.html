<p>
	[[:
		<ru>Обзор способов общения клиентской и серверной сторон приложения, осуществляемых с помощью технологии AJAX.</ru>
		<en>An overview of the methods of communication between the client and server sides of the application, implemented using AJAX technology.</en>
	:]]
</p>

<h2>[[:<ru>Содержание</ru><en>Contents</en>:]]</h2>
<ul>
	<li class="demo_nav" lx-data="pointTo:demo_app_ajax_01">Компонент Dialog</li>
	<li class="demo_nav" lx-data="pointTo:demo_app_ajax_02">Инструмент клиентской стороны lx.Request</li>
	<li class="demo_nav" lx-data="pointTo:demo_app_ajax_03">
		[[:
			<ru>Ajax-возможности модуля</ru>
			<en>Module ajax-abilities</en>
		:]]
	</li>
</ul>



<h2 id="demo_app_ajax_01"></h2>
<p>
	Взаимодействие клиента и сервера осуществляется при помощи компонента <b>Dialog</b>.
</p>
<p>
	На стороне клиента это <b>lx.Dialog</b>, подробнее разбирается в соответствующей статье (ссылка).
</p>
	На стороне сервера - <b>lx::$dialog</b>, подробнее разбирается в соответствующей статье (ссылка).
</p>
<p>
	Универсальный метод отправки запросов:
</p>
<div class="demo_code_back code"><pre>
	lx.Dialog.request({
		method,   // [[:<ru>метод "get", "post" и т.д.</ru><en>method "get" or "post" and etc.</en>:]]
		url,      // url запроса - без параметров. На стороне сервера нет специального механизма
		headers,  // заголовки запроса
		data,     // параметры запроса
		success,  // хэндлер обработки успешного ответа от сервера
		waiting,  // хэндлер обработки промежуточных ответов сервера
		error,    // хэндлер обработки при получнии в ответе ошибки от сервера
		isAjax    // булевый флаг является ли запрос ajax. По умолчанию true
	});
</pre></div>
<p>
	Метод подходит не только для ajax-запросов (что ясно из флага isAjax), его можно использовать и для кроссдоменных запросов.
</p>
<p>
	Чаще всего ajax-запросы в рамках приложения происходят в контексте конкретного модуля, что накладывает определенные требования на формирование запроса.
	Для этого предусмотрен ряд вариантов взаимодействия клиентской и серверной сторон модуля, что реализовано в ряде методов модуля.
	Соответственно для таких целей использование метода <b>lx.Dialog.request()</b> напрямую не требуется. Подробнее ниже.
</p>



<h2 id="demo_app_ajax_02"></h2>
<p>
	Сразу стоит упомянуть клиентский инструмент <b>lx.Request</b> - это класс, экземпляры которого являются удобной объектной оберткой над методом <b>lx.Dialog.request()</b>, пример:
</p>
<div class="demo_code_back code"><pre>
	// Создание экземпляра позволяет сразу определить метод и url
	var request = new lx.Request('post', 'some-url');
	
	// Установка заголовков запроса
	request.setHeaders(headers);
	
	// Установка параметров запроса
	request.setData(data);
	
	// Хэндлер можно навесить в стиле js-кода
	request.success = function(response) {
		// [[:<ru>Что-то делаем с полученными данными</ru><en>Do something with response</en>:]]
	};
	
	// Отправка запроса
	request.send();
</pre></div>
<p>
Помимо приведенного в примере есть метод <b>request.setModule(module)</b>, при помощи которого можно явно указать в контексте какого модуля делается запрос. Это действие выполняет вне необходиме требования для корректной работы запроса в контексте модуля.
</p>
<p>
Подробнее о <b>lx.Request</b> в соответствующей статье (ссылка).
</p>



<h2 id="demo_app_ajax_03"></h2>
<p>
	У модуля есть функционал для взаимодействия его клиенской и серверной сторон.
</p>
<p>
	Поскольку на клиенте доступна контекстная переменная <b>Module</b>, нет проблем с тем, чтобы исполняемый модуль
	мог обратиться к своей серверной стороне. Есть несколько способов это сделать.
</p>
<p>
	1. Использование специальных классов для формирования ответа - респондентов (ссылка).
</p>
<div class="demo_code_back code"><pre>
	// Ответ серверной части модуля с помощью респондента.
	// При этом на стороне сервера должен быть класс-респондент с названием SomeRespondent
	// и иметь метод someMethod($param1, $param2)
	Module.callToRespondent('SomeRespondent/someMethod', [param1, param2], {
		success: onSuccessHandler,
		error: onErrorHandler
	});

	// То же самое, переписанное с использованием расширенного js-синтаксиса
	// (подробнее о расширенном синтаксисе<-ссылка)
	^SomeRespondent.someMethod(param1, param2) ? onSuccessHandler : onErrorHandler;
</pre></div>
<p>
	2. Можно обойтись без респондента, если на сервере для данного модуля существует свой класс и у него переопределен метод Module::response()
</p>
<div class="demo_code_back code"><pre>
	// Ответ серверной части модуля без респондента. При этом на стороне сервера модуль должен 
	// переопределить метод Module::response()
	Module.ajax(url, [param1, param2], {
		success: onSuccessHandler,
		error: onErrorHandler
	});
<!--
	!!!!!!!//todo - еще не реализовано
	<span class="demo_code_comment">// То же самое, переписанное с использованием расширенного js-синтаксиса
	// (подробнее о расширенном синтаксисе<-ссылка)</span>
	^url(param1, param2) ? onSuccessHandler : onErrorHandler;
--></pre></div>
<p>
	3. Специальный тип обращения к серверу - загрузка вложенного модуля
</p>
<div class="demo_code_back code"><pre>
	// AJAX-загрузка модуля - вернется информация по вложенному модулю, которую можно загрузить в элемент
	// методом Box.injectModule(subModuleData);
	Module.loadModule(moduleName, params, (subModuleData)=> someBox.injectModule(subModuleData));
	[ТРЕБУЕТ ПРАВКИ - МЕТОД УДАЛЕН, ИЕРАРХИЯ МОДУЛЕЙ УПРАЗДНЕНА]
</pre></div>
<p>
	4. Активные GET AJAX-запросы, синхронизирующие адресную строку
</p>
<p>
	Бывает полезно, чтобы факт осуществления AJAX-запроса отражался в адресной строке. Например, если подгружаются данные, на основании которых строится представление, к которому удобно иметь доступ напрямую через однозначный URL. На этот случай есть активные AJAX-запросы
</p>
<div class="demo_code_back code"><pre>
	// Где-то в начале исполнения скрипта
	Module.registerActiveRequest(url, handlers);
	
	// Где-то в коде при наступлении определенных событий
	Module.activeRequest(url, data);
</pre></div>
<p>
5. Синхронизация адресной строки, но без обращений к серверу
</p>
<p>
Этот пункт не имеет отношения к общению клиента и сервера - все происходит на клиенте. Но из-за близкого родства идеи и синтаксиса с предыдущим пунктом, стоит здесь о нем рассказать.
</p>
<div class="demo_code_back code"><pre>
	// Где-то в начале исполнения скрипта
	Module.registerActiveRequest(key, handler, false <span class="demo_code_comment">/* Указывает на то, что сервер не нужен */</span>);
	
	// Где-то в коде при наступлении определенных событий
	Module.activeRequest(key, data);
</pre></div>
<p>
	Для последних двух пунктов важно понимать, что синхронизация адресной строки имеет смысл только для ведущего
	модуля. Для модулей, исполняемых во фреймах, эти методы не работают.
</p>
